# Cursor AI Rules for Pipeline Studio App

## Project Overview

This is a React + TypeScript application for building and running Machine Learning pipelines using drag and drop. The app uses Vite, TailwindCSS v4, ShadCN, Radix UI, React Flow, and Monaco Editor.

## Core Technologies & Standards

### TypeScript

- Use strict TypeScript with proper typing
- Prefer explicit types over `any` (only use `any` when absolutely necessary)
- Use interface for object shapes, type for unions/primitives
- Follow existing patterns for type definitions in `src/types/`
- **Avoid unsafe type casting**: Don't use type assertions (`as`) unless absolutely necessary. Instead prefer:
  - Type guards and runtime validation
  - Proper typing from the source
  - Union types and type narrowing
  - Schema validation libraries (e.g., zod) for external data
  - Example: Instead of `const something: string = myjson as string`, use type guards or validate the data

### React Patterns

- Use functional components with hooks exclusively
- Use proper dependency arrays in useEffect
- Follow the existing component structure
- Do not use barrel exports
- Use React 19 features and patterns
- **Import modules from React**: `import module from react`. Do not use inline `React.[module]`

### React Compiler

This project uses **React Compiler** for automatic memoization. Follow these rules:

- **DO NOT use `useMemo`, `useCallback`, or `React.memo`** in new components - React Compiler handles memoization automatically
- **When creating a new component file**, add its directory or file path to `react-compiler.config.js` in the `REACT_COMPILER_ENABLED_DIRS` array
- For new files in directories already in the allow list (e.g., `src/components/Home`, `src/routes`), no action needed
- If adding a file in a new directory, add the directory path to the config
- Existing components with `useMemo`/`useCallback` should NOT be refactored unless explicitly requested


### File Structure & Imports

- Use absolute imports with `@/` prefix for src directory
- Follow existing folder structure:
  - `src/components/` for all React components
  - `src/hooks/` for custom hooks
  - `src/types/` for TypeScript definitions
  - `src/utils/` for utility functions
  - `src/services/` for API and business logic
- **Import order**: external packages → internal modules → relative imports
- Use simple-import-sort rules (already configured in ESLint)
- Do not use barrel exports

### UI Components & Styling

- Use ShadCN / Radix UI components from `@/components/ui/` for all UI primitives
- Use TailwindCSS v4 for styling (not CSS modules or styled-components)
- **Do not use inline styling** (`style={styles}`) except where strictly necessary
- Follow existing design patterns in the codebase
- Use `cn()` utility for conditional classes (from `@/lib/utils`)
- Prefer composition over prop drilling for complex components
- **Suggest abstractions for repeated Tailwind patterns**: When you see similar Tailwind class combinations used multiple times (especially for buttons, cards, inputs, wrappers, etc), suggest creating reusable components or utility classes. For example:
  - Multiple buttons with similar styling → Create a Button variant or new component
  - Repeated container/card patterns → Abstract into reusable Card component
  - Common spacing/layout patterns → Suggest utility classes or component abstractions
  - Similar form field styling → Create form field components

### UI Primitives (Prefer Over Raw HTML)

**Always prefer our UI primitives over raw HTML elements:**

- **Layout**: Use `BlockStack` and `InlineStack` from `@/components/ui/layout` instead of `<div className="flex ...">`
  - `BlockStack` = vertical flex (`flex-col`)
  - `InlineStack` = horizontal flex (`flex-row`)
  - Both support `gap`, `align`, `blockAlign` props
  - Use `as` prop for semantic elements: `<BlockStack as="ul">`, `<InlineStack as="li">`

- **Typography**: Use `Text` from `@/components/ui/typography` instead of raw `<h1-h6>`, `<p>`, `<span>`, `<dt>`, `<dd>`
  - `<Text as="h3" size="md" weight="semibold">` instead of `<h3 className="text-md font-semibold">`
  - `<Text as="dt" weight="semibold">` instead of `<dt className="font-semibold">`
  - `<Text as="p" size="sm">` instead of `<p className="text-sm">`
  - Supports: `as`, `size`, `weight`, `tone`, `font` props

- **Buttons**: Use `Button` from `@/components/ui/button`
- **Icons**: Use `Icon` from `@/components/ui/icon`

**When raw HTML is acceptable:**

- Semantic elements not supported by primitives (e.g., `<dl>`, `<ul>`, `<ol>`, `<table>`)
- Complex layouts where primitives don't fit
- Performance-critical sections where abstraction overhead matters

### State Management

- Use Tanstack Query for server state
- Use Tanstack Router for routing
- Use React hooks for local component state
- Use Context providers for app-wide state (see existing providers)
- Follow existing patterns in `src/providers/`
- **Use `useRequiredContext`** to simplify context usage and avoid null checks

### Code Quality

- Follow ESLint rules (configured in eslint.config.js)
- Use Prettier for formatting
- Write tests using Vitest for unit tests, Playwright for E2E
- Use descriptive variable and function names
- Add JSDoc comments for complex functions
- Prefer early returns to reduce nesting

### API & Data

- Use the generated API client in `src/api/`
- Follow existing service patterns in `src/services/`
- Use proper error handling with try/catch
- **Prefer domain types**: Use types from `src/utils/componentSpec.ts`, `src/types/`, etc. for core business logic
- **Use generated API types**: Only use `src/api/types.gen.ts` when directly interfacing with APIs or when domain types don't exist
- **Avoid unsafe type casting**: Don't use type assertions (`as`) unless absolutely necessary. Instead prefer:
  - Type guards and runtime validation
  - Proper typing from the source
  - Union types and type narrowing
  - Schema validation libraries for external data
  - Example: Instead of `const something: string = myjson as string`, use type guards or validate the data

### React Flow Specific

- Use `@xyflow/react` for flow diagrams
- Follow existing node types and edge patterns
- Keep flow state management consistent with existing patterns
- Use proper node and edge typing

### Testing

#### Unit & Component Tests

- Write unit tests for utilities and hooks using Vitest
- Write component tests for complex components
- Follow existing test patterns and naming

#### E2E Tests with Playwright

- Use Playwright helpers from `tests/e2e/helpers.ts`
- Follow Playwright best practices (see E2E Testing Best Practices section below)
- Use `data-testid` attributes for stable selectors
- Write descriptive test names that explain user behavior
- Ensure tests are isolated and can run independently

### E2E Testing Best Practices (Playwright)

#### Never Use Hard-Coded Timeouts

**❌ Don't:**

```typescript
await element.click();
await page.waitForTimeout(200); // Flaky and slow
```

**✅ Do:**

```typescript
await element.click();
await expect(otherElement).toBeVisible(); // Wait for actual state
```

#### Use Playwright's Auto-Waiting

**❌ Don't:**

```typescript
if (await element.isVisible()) {
  await element.click();
}
```

**✅ Do:**

```typescript
await expect(element).toBeVisible();
await element.click(); // Playwright auto-waits
```

#### Never Use Non-Null Assertions

**❌ Don't:**

```typescript
const box = await element.boundingBox();
const x = box!.x; // Crashes if null
```

**✅ Do:**

```typescript
const box = await element.boundingBox();
if (!box) {
  throw new Error("Unable to locate element bounding box");
}
const x = box.x;
```

#### Don't Await Locators (They're Lazy)

**❌ Don't:**

```typescript
const button = await page.getByTestId("submit");
const items = await page.locator(".item");
await expect(button).toBeVisible();
```

**✅ Do:**

```typescript
const button = page.getByTestId("submit"); // No await
const items = page.locator(".item"); // No await
await expect(button).toBeVisible(); // Only await assertions
```

#### Use Consistent Assertion Patterns

**❌ Don't:**

```typescript
expect(await element).toHaveText("text");
expect(await element.isVisible()).toBe(true);
```

**✅ Do:**

```typescript
await expect(element).toHaveText("text");
await expect(element).toBeVisible();
```

#### Prefer Semantic Selectors

**Priority order:**

1. `getByRole()` - Best for accessibility
2. `getByTestId()` - Best for test stability (use this for our app)
3. `getByText()` - Good for static content
4. `locator()` with data attributes - When above don't work
5. CSS selectors - Last resort

**❌ Don't:**

```typescript
await page.locator(".button.primary.submit").click();
```

**✅ Do:**

```typescript
await page.getByTestId("submit-button").click();
```

#### Write Isolated, Independent Tests

- Each test should set up its own state
- Don't depend on test execution order (unless using serial mode intentionally)
- Clean up after tests in `afterEach` or `afterAll`

#### Use Helper Functions

- Leverage existing helpers from `tests/e2e/helpers.ts`
- Create new helpers for repeated workflows
- Keep helpers focused and reusable

#### Add Meaningful Error Context

**❌ Don't:**

```typescript
await expect(element).toBeVisible();
```

**✅ Do:**

```typescript
await expect(element, "Component should appear after loading").toBeVisible();
```

#### Test User Behavior, Not Implementation

**❌ Don't:**

```typescript
await expect(button).toHaveClass("bg-blue-500"); // Implementation detail
```

**✅ Do:**

```typescript
await expect(button).toBeVisible();
await expect(button).toBeEnabled();
await expect(button).toHaveText("Submit"); // User-visible behavior
```

### Performance

- Use memo for expensive components
- Use useMemo and useCallback appropriately
- Lazy load heavy components when possible
- Follow existing patterns for optimization

## Component Architecture

### Component Structure

```typescript
// ComponentName/index.ts
export { ComponentName } from './ComponentName';

// ComponentName/ComponentName.tsx
interface ComponentNameProps {
  // props
}

export const ComponentName = ({ }: ComponentNameProps) => {
  // component logic
  return (
    // JSX
  );
};
```

### Custom Hooks

- Prefix with `use`
- Return objects for multiple values, not arrays
- Use proper TypeScript return types
- Follow existing patterns in `src/hooks/`

### Provider Pattern

```typescript
const Context = createContext<ContextType | null>(null);

export const Provider = ({ children }: { children: ReactNode }) => {
  // provider logic
  return <Context.Provider value={value}>{children}</Context.Provider>;
};

export const useContext = () => {
  const context = useContext(Context);
  if (!context) throw new Error('useContext must be used within Provider');
  return context;
};
```

## Naming Conventions

- Components: PascalCase
- Files: PascalCase for components, camelCase for utilities
- Variables/functions: camelCase
- Constants: SCREAMING_SNAKE_CASE
- Types/Interfaces: PascalCase
- Directories: camelCase or PascalCase for component folders

## Error Handling

- Use proper error boundaries
- Handle async errors with try/catch
- Use toast notifications for user-facing errors
- Log errors appropriately
- Follow existing error patterns

## Comments & Documentation

- Use JSDoc for public APIs
- Add comments for complex business logic
- **Explain "why" not "what" in comments**
- **Keep comments up to date with code changes**
- Avoid writing redundant comments for functions and variables that are self-explanatory

## Specific Project Patterns

- Use Monaco Editor for code editing features
- Follow React Flow patterns for pipeline visualization
- Use localforage for client-side storage
- Follow existing authentication patterns
- Use proper task node and pipeline handling patterns
- Follow the existing component library structure
- **Do not modify componentSpec structure** without express permission beforehand

## Don't Do

### General

- Don't use CSS-in-JS or styled-components
- Don't use inline styling (`style={styles}`) except where strictly necessary
- Don't use class components
- Don't ignore TypeScript errors
- Don't use relative imports for `@/components/ui`
- Don't create new global state without good reason
- Don't bypass existing abstractions without discussion
- Don't use `any` type without explicit justification
- Don't use unsafe type casting (`as`) unless absolutely necessary
- Don't create side effects in render functions
- Don't use barrel exports
- Don't modify componentSpec structure without express permission
- Don't use raw HTML elements when UI primitives exist (use `Text`, `BlockStack`, `InlineStack`, etc.)

### E2E Testing

- Don't use `page.waitForTimeout()` - use proper Playwright auto-waiting instead
- Don't use non-null assertions (`!`) - add explicit null checks with error messages
- Don't await locators - only await assertions and actions
- Don't test implementation details (CSS classes, internal state) - test user-visible behavior
- Don't write comments that just restate what the code does - explain "why" not "what"

## Other rules

- Prioritize readability over complexity
- Reuse existing components, types, and styles whenever possible, and avoid over-generating new ones.
- Avoid writing redundant comments for functions and variables that are self-explanatory.

When suggesting code changes, always follow these patterns and maintain consistency with the existing codebase.
